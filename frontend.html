<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cody: 3D ì¸í„°ë™í‹°ë¸Œ ì½”ë“œ ë¶„ì„ (ìš°ì£¼ í…Œë§ˆ)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect"             const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.3; // ì„ê³„ê°’ì„ ë‚®ì¶°ì„œ ë” ë§ì€ ë…¸ë“œê°€ ë¹›ë‚˜ë„ë¡
            bloomPass.strength = 4.0;  // ë¸”ë£¸ ê°•ë„ ìµœëŒ€ë¡œ
            bloomPass.radius = 1.5;    // ë¸”ë£¸ ë°˜ì§€ë¦„ ìµœëŒ€ë¡œ"https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/"
        }
    }
    </script>
    <style>
        body {
            font-family: 'Inter', 'Noto Sans KR', sans-serif;
            background-color: #000005;
            color: #f0f0f0;
            overflow: hidden;
        }
        #main-canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        .sidebar {
            position: fixed;
            top: 0;
            left: 0;
            height: 100%;
            width: 450px;
            transform: translateX(-100%);
            transition: transform 0.4s ease-in-out;
            z-index: 10;
            display: flex;
            flex-direction: column;
        }
        .sidebar.open {
            transform: translateX(0);
        }
        .sidebar-toggle {
            position: fixed;
            top: 50%;
            left: 1rem;
            transform: translateY(-50%);
            z-index: 11;
            transition: left 0.4s ease-in-out;
        }
        .sidebar.open + .sidebar-toggle {
            left: 460px;
        }
        .glassmorphism {
            background: rgba(10, 10, 15, 0.7);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .code-editor {
            font-family: 'D2Coding', 'SF Mono', 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.6;
            background-color: rgba(0, 0, 5, 0.8);
            color: #a9b1d6;
            border-radius: 0.5rem;
            padding: 1rem;
            height: calc(100vh - 350px);
            overflow: auto;
            white-space: pre-wrap;
            border: 1px solid rgba(255, 255, 255, 0.15);
        }
        .tab-button.active { color: #818cf8; border-bottom-color: #818cf8; }
        .node-label {
            color: #ffffff;
            background: rgba(0, 0, 0, 0.8);
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: bold;
            pointer-events: none;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.3);
            white-space: nowrap;
            min-width: 60px;
            text-align: center;
        }
        .bottom-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            z-index: 5;
        }
        #toast-container {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 20;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        .toast {
            transition: all 0.5s ease-in-out;
            opacity: 0;
            transform: translateX(100%);
        }
        .toast.show {
            opacity: 1;
            transform: translateX(0);
        }
        .file-input {
            background: rgba(30, 30, 40, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 0.5rem;
            padding: 0.5rem;
            color: #e0e0e0;
            width: 100%;
            margin-bottom: 1rem;
        }
        .dead-code {
            color: #ff6b6b !important;
        }
        .high-call-count {
            color: #ffd93d !important;
        }
    </style>
</head>
<body>
    <div id="main-canvas-container"></div>
    <div id="toast-container"></div>

    <aside id="sidebar" class="sidebar glassmorphism p-4">
        <div class="flex-grow flex flex-col">
            <h2 class="text-2xl font-bold text-white mb-4">ğŸ¤– Cody</h2>
            
            <!-- Project Path Input -->
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-300 mb-2">ë¶„ì„í•  í”„ë¡œì íŠ¸ ê²½ë¡œ</label>
                <input type="text" id="project-path" class="file-input" 
                       placeholder="ì˜ˆ: C:\path\to\your\project" 
                       value="sample_project">
                <button id="analyze-btn" class="w-full bg-blue-600 text-white py-2 px-4 rounded hover:bg-blue-700 transition">
                    <i data-lucide="search"></i> ë¶„ì„ ì‹œì‘
                </button>
            </div>

            <div class="border-b border-gray-700 mb-4">
                <nav class="-mb-px flex space-x-6" aria-label="Tabs">
                    <button id="tab-analysis" class="tab-button active py-3 px-1 text-base font-medium border-b-2 border-transparent transition">ë¶„ì„ ê²°ê³¼</button>
                    <button id="tab-code" class="tab-button py-3 px-1 text-base font-medium text-gray-400 border-b-2 border-transparent transition">ì½”ë“œ ë·°</button>
                    <button id="tab-stats" class="tab-button py-3 px-1 text-base font-medium text-gray-400 border-b-2 border-transparent transition">í†µê³„</button>
                </nav>
            </div>
            
            <div id="content-analysis" class="flex-grow">
                <h3 class="font-semibold mb-2 text-gray-200">ğŸŒŒ ì½”ë“œ ìš°ì£¼ ë¶„ì„</h3>
                <div id="analysis-info" class="bg-gray-800/50 p-3 rounded-lg text-sm space-y-2 mb-4">
                    <p>í”„ë¡œì íŠ¸ë¥¼ ë¶„ì„í•˜ë©´ 3D ìš°ì£¼ê°€ ìƒì„±ë©ë‹ˆë‹¤.</p>
                    <ul class="text-xs space-y-1 text-gray-400">
                        <li>ğŸŒŸ <strong>ë°ì€ ë…¸ë“œ</strong>: ë§ì´ í˜¸ì¶œë˜ëŠ” í•¨ìˆ˜</li>
                        <li>ğŸ’€ <strong>ë¹¨ê°„ ë…¸ë“œ</strong>: Dead Code (ë¯¸ì‚¬ìš© ì½”ë“œ)</li>
                        <li>ğŸ”— <strong>ì—°ê²°ì„ </strong>: í•¨ìˆ˜ í˜¸ì¶œ ê´€ê³„</li>
                        <li>ğŸ¯ <strong>í´ë¦­</strong>: ë…¸ë“œ ì •ë³´ í™•ì¸</li>
                    </ul>
                </div>
                <div id="node-details" class="bg-gray-800/50 p-3 rounded-lg text-sm hidden">
                    <h4 class="font-semibold text-white mb-2">ì„ íƒëœ ë…¸ë“œ</h4>
                    <div id="node-info"></div>
                </div>
            </div>
            
            <div id="content-code" class="hidden flex-grow">
                <h3 class="font-semibold mb-2 text-gray-200">ğŸ“„ ì½”ë“œ ë¯¸ë¦¬ë³´ê¸°</h3>
                <div id="code-viewer" class="code-editor">
                    ë¶„ì„ í›„ ì½”ë“œê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.
                </div>
            </div>
            
            <div id="content-stats" class="hidden flex-grow">
                <h3 class="font-semibold mb-2 text-gray-200">ğŸ“Š ìƒì„¸ í†µê³„</h3>
                <div id="detailed-stats" class="bg-gray-800/50 p-3 rounded-lg text-sm space-y-2">
                    ë¶„ì„ í›„ ìƒì„¸ í†µê³„ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.
                </div>
            </div>
        </div>
    </aside>
    
    <button id="sidebar-toggle" class="sidebar-toggle glassmorphism p-2 rounded-full text-white transition-all duration-400">
        <i data-lucide="panel-left-close"></i>
    </button>

    <div class="bottom-bar p-4 flex justify-center">
        <div class="w-full max-w-2xl">
            <div class="glassmorphism p-4 rounded-xl shadow-2xl">
                <button id="refresh-btn" class="w-full bg-indigo-600 text-white font-bold py-3 px-6 rounded-lg hover:bg-indigo-700 focus:outline-none focus:ring-4 focus:ring-indigo-500/50 transition-all duration-300 flex items-center justify-center text-lg shadow-lg">
                    <i data-lucide="refresh-cw" class="mr-2"></i>
                    <span id="refresh-btn-text">3D ê·¸ë˜í”„ ìƒˆë¡œê³ ì¹¨</span>
                </button>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- Configuration ---
        const API_BASE_URL = 'http://127.0.0.1:8000';

        // --- UI Elements ---
        const analyzeBtn = document.getElementById('analyze-btn');
        const refreshBtn = document.getElementById('refresh-btn');
        const projectPathInput = document.getElementById('project-path');
        const sidebar = document.getElementById('sidebar');
        const sidebarToggle = document.getElementById('sidebar-toggle');
        
        // Tab elements
        const tabAnalysis = document.getElementById('tab-analysis');
        const tabCode = document.getElementById('tab-code');
        const tabStats = document.getElementById('tab-stats');
        const contentAnalysis = document.getElementById('content-analysis');
        const contentCode = document.getElementById('content-code');
        const contentStats = document.getElementById('content-stats');
        
        // Content elements
        const analysisInfo = document.getElementById('analysis-info');
        const nodeDetails = document.getElementById('node-details');
        const nodeInfo = document.getElementById('node-info');
        const codeViewer = document.getElementById('code-viewer');
        const detailedStats = document.getElementById('detailed-stats');

        // --- API Functions ---
        async function analyzeProject(projectPath) {
            try {
                showToast('search', 'í”„ë¡œì íŠ¸ ë¶„ì„ ì‹œì‘...');
                
                const response = await fetch(`${API_BASE_URL}/analyze`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ path: projectPath })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const result = await response.json();
                showToast('check-circle-2', `ë¶„ì„ ì™„ë£Œ! ${result.nodes_count}ê°œ ë…¸ë“œ, ${result.edges_count}ê°œ ì—°ê²°`);
                return result;
            } catch (error) {
                console.error('Analysis error:', error);
                showToast('alert-triangle', `ë¶„ì„ ì‹¤íŒ¨: ${error.message}`);
                throw error;
            }
        }

        async function getGraphData() {
            try {
                const response = await fetch(`${API_BASE_URL}/graph-data`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                return await response.json();
            } catch (error) {
                console.error('Graph data error:', error);
                showToast('alert-triangle', `ê·¸ë˜í”„ ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨: ${error.message}`);
                throw error;
            }
        }

        async function getStatistics() {
            try {
                const response = await fetch(`${API_BASE_URL}/statistics`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                return await response.json();
            } catch (error) {
                console.error('Statistics error:', error);
                return {};
            }
        }

        // --- 3D Scene Setup ---
        let scene, camera, renderer, labelRenderer, controls, composer;
        let nodeObjects = new Map();
        let edgeObjects = [];
        let raycaster, mouse;
        let currentGraphData = null;
        
        const canvasContainer = document.getElementById('main-canvas-container');

        function onWindowResize() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
            labelRenderer.setSize(width, height);
            composer.setSize(width, height);
        }

        function init3D() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 0, 120); // ì¹´ë©”ë¼ë¥¼ ë” ë’¤ë¡œ

            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            canvasContainer.appendChild(renderer.domElement);

            labelRenderer = new CSS2DRenderer();
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0px';
            labelRenderer.domElement.style.pointerEvents = 'none';
            canvasContainer.appendChild(labelRenderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 20;
            controls.maxDistance = 300;
            controls.autoRotate = false; // ìë™ íšŒì „ ë¹„í™œì„±í™”
            controls.enablePan = true;

            // Mouse interaction setup
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            renderer.domElement.addEventListener('click', onMouseClick);

            scene.add(new THREE.AmbientLight(0xffffff, 0.2));
            const pointLight = new THREE.PointLight(0xffffff, 0.8);
            scene.add(pointLight);

            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.5; // ë†’ì€ ì„ê³„ê°’ìœ¼ë¡œ ìì£¼ ì‚¬ìš©ë˜ëŠ” ê²ƒë§Œ ë¸”ë£¸
            bloomPass.strength = 2.0;  // ë¸”ë£¸ ê°•ë„ ì¦ê°€
            bloomPass.radius = 1.0;    // ë¸”ë£¸ ë°˜ê²½ ì¦ê°€

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            createStarfield();
            window.addEventListener('resize', onWindowResize);
            animate();
        }

        function onMouseClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const sprites = Array.from(nodeObjects.values()).map(n => n.sprite);
            const intersects = raycaster.intersectObjects(sprites);

            if (intersects.length > 0) {
                const clickedSprite = intersects[0].object;
                const nodeData = Array.from(nodeObjects.values()).find(n => n.sprite === clickedSprite)?.data;
                
                if (nodeData) {
                    displayNodeDetails(nodeData);
                    switchTab('analysis');
                }
            }
        }

        function displayNodeDetails(nodeData) {
            nodeDetails.classList.remove('hidden');
            const callCount = nodeData.callCount || 0;
            const isDead = nodeData.dead || false;
            const isUnused = callCount === 0 && !isDead;
            
            let statusText = '';
            let statusClass = '';
            
            if (isDead) {
                statusText = 'âš ï¸ ë°ë“œ ì½”ë“œ (vulture ë¶„ì„)';
                statusClass = 'text-red-400';
            } else if (callCount > 5) {
                statusText = 'ğŸ”¥ ìì£¼ ì‚¬ìš©ë˜ëŠ” í•µì‹¬ í•¨ìˆ˜';
                statusClass = 'text-yellow-400';
            } else if (isUnused) {
                statusText = 'ğŸ’¤ í˜¸ì¶œ ì•ˆë¨ (í•˜ì§€ë§Œ í•„ìš”í•œ ì½”ë“œ)';
                statusClass = 'text-gray-400';
            } else if (nodeData.type === 'class') {
                statusText = 'ğŸ—ï¸ í´ë˜ìŠ¤ ì •ì˜';
                statusClass = 'text-purple-400';
            } else {
                statusText = 'âœ… ì¼ë°˜ í•¨ìˆ˜';
                statusClass = 'text-blue-400';
            }
            
            nodeInfo.innerHTML = `
                <p><strong>ì´ë¦„:</strong> ${nodeData.name}</p>
                <p><strong>íƒ€ì…:</strong> ${nodeData.type}</p>
                <p><strong>íŒŒì¼:</strong> ${nodeData.file}</p>
                <p><strong>í˜¸ì¶œ íšŸìˆ˜:</strong> ${callCount}íšŒ</p>
                <p><strong>ìƒíƒœ:</strong> <span class="${statusClass}">${statusText}</span></p>
                ${isDead ? '<p class="text-red-400 text-xs mt-1">âš ï¸ ì´ ì½”ë“œëŠ” ì‹¤ì œë¡œ ì‚¬ìš©ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì œê±°ë¥¼ ê³ ë ¤í•´ë³´ì„¸ìš”.</p>' : ''}
                ${isUnused ? '<p class="text-gray-400 text-xs mt-1">ğŸ’¡ ASTì—ì„œ í˜¸ì¶œì´ ê°ì§€ë˜ì§€ ì•Šì•˜ì§€ë§Œ, vultureëŠ” í•„ìš”í•œ ì½”ë“œë¼ê³  íŒë‹¨í–ˆìŠµë‹ˆë‹¤.</p>' : ''}
                ${callCount > 5 ? '<p class="text-yellow-400 text-xs mt-1">ğŸš€ ì´ í•¨ìˆ˜ëŠ” í”„ë¡œì íŠ¸ì˜ í•µì‹¬ ë¡œì§ì…ë‹ˆë‹¤.</p>' : ''}
            `;
        }

        function createStarfield() {
            const starGeometry = new THREE.BufferGeometry();
            const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.1, transparent: true, opacity: 0.5 });
            const starVertices = [];
            for (let i = 0; i < 10000; i++) {
                const x = (Math.random() - 0.5) * 3000;
                const y = (Math.random() - 0.5) * 3000;
                const z = (Math.random() - 0.5) * 3000;
                starVertices.push(x, y, z);
            }
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        }

        function createStarTexture(color, isDead = false, isHighUsage = false) {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const context = canvas.getContext('2d');
            
            if (isDead) {
                // Dead code - ê±°ì˜ ë³´ì´ì§€ ì•Šì„ ì •ë„ë¡œ ì–´ë‘¡ê²Œ
                const gradient = context.createRadialGradient(64, 64, 0, 64, 64, 64);
                gradient.addColorStop(0, 'rgba(30, 8, 8, 0.6)');
                gradient.addColorStop(0.5, 'rgba(20, 5, 5, 0.3)');
                gradient.addColorStop(1, 'rgba(10, 2, 2, 0)');
                context.fillStyle = gradient;
                context.fillRect(0, 0, 128, 128);
            } else if (isHighUsage) {
                // ìì£¼ ì‚¬ìš© - íƒœì–‘ì²˜ëŸ¼ ê·¹ë„ë¡œ ë°ê²Œ
                const gradient = context.createRadialGradient(64, 64, 0, 64, 64, 64);
                gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                gradient.addColorStop(0.05, 'rgba(255, 255, 255, 1)');
                gradient.addColorStop(0.15, 'rgba(255, 255, 200, 1)');
                gradient.addColorStop(0.4, 'rgba(255, 220, 100, 1)');
                gradient.addColorStop(0.7, 'rgba(255, 180, 50, 0.9)');
                gradient.addColorStop(1, 'rgba(255, 140, 0, 0)');
                context.fillStyle = gradient;
                context.fillRect(0, 0, 128, 128);
                
                // ê·¹ë„ë¡œ ê°•í•œ ê¸€ë¡œìš° íš¨ê³¼
                context.globalCompositeOperation = 'lighter';
                const glowGradient = context.createRadialGradient(64, 64, 0, 64, 64, 110);
                glowGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                glowGradient.addColorStop(0.1, 'rgba(255, 255, 220, 0.9)');
                glowGradient.addColorStop(0.3, 'rgba(255, 240, 150, 0.7)');
                glowGradient.addColorStop(0.6, 'rgba(255, 220, 100, 0.4)');
                glowGradient.addColorStop(1, 'rgba(255, 200, 50, 0)');
                context.fillStyle = glowGradient;
                context.fillRect(0, 0, 128, 128);
            } else {
                // ì¼ë°˜ í•¨ìˆ˜/í´ë˜ìŠ¤ - ì°¨ë¶„í•˜ê³  ì–´ë‘¡ê²Œ, ë¸”ë£¸ ì—†ìŒ
                const gradient = context.createRadialGradient(64, 64, 0, 64, 64, 64);
                gradient.addColorStop(0, color.replace('1)', '0.7)'));
                gradient.addColorStop(0.4, color.replace('1)', '0.4)'));
                gradient.addColorStop(0.8, color.replace('1)', '0.2)'));
                gradient.addColorStop(1, color.replace('1)', '0)'));
                context.fillStyle = gradient;
                context.fillRect(0, 0, 128, 128);
            }
            
            return new THREE.CanvasTexture(canvas);
        }
        
        function createGraph3D(graphData) {
            // Clear existing objects
            nodeObjects.forEach(obj => {
                scene.remove(obj.sprite);
            });
            edgeObjects.forEach(obj => {
                scene.remove(obj);
            });
            nodeObjects.clear();
            edgeObjects = [];
            
            currentGraphData = graphData;
            
            if (!graphData.nodes || graphData.nodes.length === 0) {
                showToast('alert-triangle', 'í‘œì‹œí•  ë…¸ë“œê°€ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            const nodeCount = graphData.nodes.length;
            const radius = Math.max(30, 15 + nodeCount * 0.8); // ë°˜ì§€ë¦„ í¬ê²Œ ì¦ê°€

            graphData.nodes.forEach((nodeData, i) => {
                // ë” ë„“ê²Œ ë¶„ì‚°ëœ êµ¬í˜• ë°°ì¹˜
                const phi = Math.acos(-1 + (2 * i) / nodeCount);
                const theta = Math.sqrt(nodeCount * Math.PI) * phi * 1.5; // ë” ë„“ê²Œ ë¶„ì‚°

                // Determine color and size based on node properties
                const isDead = nodeData.dead || false;
                const callCount = nodeData.callCount || 0;
                const isHighUsage = callCount > 3;
                const isUnused = callCount === 0 && !isDead; // í˜¸ì¶œíšŸìˆ˜ 0ì´ì§€ë§Œ ë°ë“œì½”ë“œ ì•„ë‹˜
                
                let color, size, blending, opacity;
                if (isDead) {
                    // ì§„ì§œ ë°ë“œì½”ë“œ: ê·¹ë„ë¡œ ì–´ë‘¡ê³  ì‘ê²Œ, ë¹¨ê°„ìƒ‰
                    color = 'rgba(40, 10, 10, 1)';
                    size = 0.5;
                    blending = THREE.NormalBlending;
                    opacity = 0.4;
                } else if (isHighUsage) {
                    // ìì£¼ ì‚¬ìš©: ê·¹ë„ë¡œ í¬ê³  ë°ê²Œ, í™©ê¸ˆìƒ‰
                    color = 'rgba(255, 255, 255, 1)';
                    size = 6.0 + (callCount * 0.5);
                    blending = THREE.AdditiveBlending;
                    opacity = 1.0;
                } else if (nodeData.type === 'class') {
                    // í´ë˜ìŠ¤: ë³´ë¼ìƒ‰, ì¤‘ê°„ í¬ê¸°
                    color = 'rgba(150, 120, 200, 1)';
                    size = 2.5;
                    blending = THREE.NormalBlending;
                    opacity = 0.8;
                } else if (isUnused) {
                    // í˜¸ì¶œíšŸìˆ˜ 0ì´ì§€ë§Œ ì‚¬ìš©ë˜ëŠ” í•¨ìˆ˜: íšŒìƒ‰, ì‘ì€ í¬ê¸°
                    color = 'rgba(120, 120, 120, 1)';
                    size = 1.2;
                    blending = THREE.NormalBlending;
                    opacity = 0.6;
                } else {
                    // ì¼ë°˜ í•¨ìˆ˜: íŒŒë€ìƒ‰, ë³´í†µ í¬ê¸°
                    color = 'rgba(100, 150, 220, 1)';
                    size = 2.0;
                    blending = THREE.NormalBlending;
                    opacity = 0.7;
                }

                const starMaterial = new THREE.SpriteMaterial({
                    map: createStarTexture(color, isDead, isHighUsage),
                    blending: blending,
                    depthWrite: false,
                    transparent: true,
                    opacity: opacity
                });

                const sprite = new THREE.Sprite(starMaterial);
                sprite.scale.set(size * 2.0, size * 2.0, 1); // ì „ì²´ì ìœ¼ë¡œ ë” í¬ê²Œ
                
                const position = new THREE.Vector3();
                position.setFromSphericalCoords(radius, phi, theta);
                sprite.position.copy(position);
                
                // Create label with color coding
                const labelElement = document.createElement('div');
                labelElement.className = 'node-label';
                labelElement.style.fontSize = '14px';
                labelElement.style.fontWeight = 'bold';
                labelElement.style.padding = '4px 8px';
                labelElement.style.borderRadius = '6px';
                labelElement.style.border = '1px solid rgba(255, 255, 255, 0.3)';
                labelElement.style.textShadow = '1px 1px 2px rgba(0, 0, 0, 0.8)';
                labelElement.style.whiteSpace = 'nowrap';
                labelElement.style.pointerEvents = 'none';
                
                if (isDead) {
                    labelElement.classList.add('dead-code');
                    labelElement.style.backgroundColor = 'rgba(220, 40, 40, 1)';
                    labelElement.style.color = '#ffffff';
                    labelElement.style.border = '2px solid rgba(255, 80, 80, 0.8)';
                    labelElement.style.fontWeight = 'bold';
                    labelElement.style.textShadow = '2px 2px 4px rgba(0, 0, 0, 1)';
                } else if (isHighUsage) {
                    labelElement.classList.add('high-call-count');
                    labelElement.style.backgroundColor = 'rgba(255, 220, 60, 1)';
                    labelElement.style.color = '#000000';
                    labelElement.style.border = '2px solid rgba(255, 240, 120, 1)';
                    labelElement.style.fontWeight = 'bold';
                    labelElement.style.textShadow = '1px 1px 3px rgba(0, 0, 0, 0.8)';
                } else if (nodeData.type === 'class') {
                    labelElement.style.backgroundColor = 'rgba(150, 120, 200, 0.9)';
                    labelElement.style.color = '#ffffff';
                    labelElement.style.border = '1px solid rgba(180, 150, 220, 0.8)';
                } else if (isUnused) {
                    labelElement.style.backgroundColor = 'rgba(120, 120, 120, 0.8)';
                    labelElement.style.color = '#ffffff';
                    labelElement.style.border = '1px solid rgba(160, 160, 160, 0.6)';
                } else {
                    labelElement.style.backgroundColor = 'rgba(100, 150, 220, 0.8)';
                    labelElement.style.color = '#ffffff';
                    labelElement.style.border = '1px solid rgba(130, 170, 240, 0.6)';
                }
                
                labelElement.textContent = nodeData.name || nodeData.label;
                
                const label = new CSS2DObject(labelElement);
                label.position.set(0, size * 1.2, 0); // ë¼ë²¨ì„ ë” ìœ„ë¡œ
                sprite.add(label);

                scene.add(sprite);
                nodeObjects.set(nodeData.id, { sprite, data: nodeData });
            });

            // Create edges/connections
            if (graphData.links) {
                graphData.links.forEach(linkData => {
                    const fromNode = nodeObjects.get(linkData.source);
                    const toNode = nodeObjects.get(linkData.target);
                    if (fromNode && toNode) {
                        const material = new THREE.MeshBasicMaterial({ 
                            color: 0x00ffff, 
                            transparent: true, 
                            opacity: 0.4 
                        });
                        const path = new THREE.LineCurve3(fromNode.sprite.position, toNode.sprite.position);
                        const geometry = new THREE.TubeGeometry(path, 2, 0.02, 8, false);
                        const tube = new THREE.Mesh(geometry, material);
                        scene.add(tube);
                        edgeObjects.push(tube);
                    }
                });
            }

            showToast('sparkles', `3D ìš°ì£¼ ìƒì„± ì™„ë£Œ! ${nodeCount}ê°œ ë…¸ë“œ, ${edgeObjects.length}ê°œ ì—°ê²°`);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            composer.render();
            labelRenderer.render(scene, camera);
        }

        function showToast(icon, text) {
            const toastContainer = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = 'toast glassmorphism p-3 rounded-lg flex items-center shadow-lg';
            toast.innerHTML = `<i data-lucide="${icon}" class="w-5 h-5 mr-3 text-indigo-400"></i><span>${text}</span>`;
            
            toastContainer.appendChild(toast);
            lucide.createIcons();

            setTimeout(() => toast.classList.add('show'), 10);
            setTimeout(() => {
                toast.classList.remove('show');
                toast.addEventListener('transitionend', () => toast.remove());
            }, 4000);
        }

        function switchTab(tabName) {
            // Reset all tabs
            [tabAnalysis, tabCode, tabStats].forEach(tab => tab.classList.remove('active'));
            [contentAnalysis, contentCode, contentStats].forEach(content => content.classList.add('hidden'));
            
            // Activate selected tab
            if (tabName === 'analysis') {
                tabAnalysis.classList.add('active');
                contentAnalysis.classList.remove('hidden');
            } else if (tabName === 'code') {
                tabCode.classList.add('active');
                contentCode.classList.remove('hidden');
            } else if (tabName === 'stats') {
                tabStats.classList.add('active');
                contentStats.classList.remove('hidden');
            }
        }
        
        function updateAnalysisInfo(analysisResult) {
            analysisInfo.innerHTML = `
                <div class="space-y-2">
                    <p><strong>âœ¨ ë¶„ì„ ì™„ë£Œ!</strong></p>
                    <p>ğŸŒŸ <strong>ë…¸ë“œ:</strong> ${analysisResult.nodes_count}ê°œ</p>
                    <p>ğŸ”— <strong>ì—°ê²°:</strong> ${analysisResult.edges_count}ê°œ</p>
                    <p class="text-xs text-gray-400 mt-2">3D ìš°ì£¼ì—ì„œ ë…¸ë“œë¥¼ í´ë¦­í•˜ì—¬ ìì„¸í•œ ì •ë³´ë¥¼ í™•ì¸í•˜ì„¸ìš”.</p>
                </div>
            `;
        }
        
        function updateDetailedStats(stats) {
            if (!stats || Object.keys(stats).length === 0) {
                detailedStats.innerHTML = '<p class="text-gray-400">í†µê³„ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.</p>';
                return;
            }
            
            let html = `
                <div class="space-y-3">
                    <div>
                        <h4 class="font-semibold text-white mb-1">ğŸ“Š ì „ì²´ í˜„í™©</h4>
                        <p>ì „ì²´ ë…¸ë“œ: ${stats.total_nodes || 0}ê°œ</p>
                        <p>ì „ì²´ ê´€ê³„: ${stats.total_relationships || 0}ê°œ</p>
                        <p>ğŸ’€ Dead Code: ${stats.dead_code_count || 0}ê°œ</p>
                    </div>
            `;
            
            if (stats.by_type) {
                html += `
                    <div>
                        <h4 class="font-semibold text-white mb-1">ğŸ“‹ íƒ€ì…ë³„ ë¶„í¬</h4>
                `;
                for (const [type, count] of Object.entries(stats.by_type)) {
                    html += `<p>${type}: ${count}ê°œ</p>`;
                }
                html += `</div>`;
            }
            
            if (stats.most_called && stats.most_called.length > 0) {
                html += `
                    <div>
                        <h4 class="font-semibold text-white mb-1">ğŸ”¥ ìµœë‹¤ í˜¸ì¶œ í•¨ìˆ˜</h4>
                `;
                stats.most_called.slice(0, 5).forEach((item, i) => {
                    html += `<p class="text-sm">${i+1}. ${item.name} (${item.callCount}íšŒ)</p>`;
                });
                html += `</div>`;
            }
            
            html += '</div>';
            detailedStats.innerHTML = html;
        }

        async function runAnalysisWorkflow() {
            const projectPath = projectPathInput.value.trim();
            if (!projectPath) {
                showToast('alert-triangle', 'í”„ë¡œì íŠ¸ ê²½ë¡œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                return;
            }

            analyzeBtn.disabled = true;
            analyzeBtn.innerHTML = '<i data-lucide="loader-2" class="animate-spin"></i> ë¶„ì„ ì¤‘...';
            
            try {
                // Step 1: Analyze project
                const analysisResult = await analyzeProject(projectPath);
                updateAnalysisInfo(analysisResult);
                
                // Step 2: Get graph data and statistics
                const [graphData, stats] = await Promise.all([
                    getGraphData(),
                    getStatistics()
                ]);
                
                // Step 3: Create 3D visualization
                createGraph3D(graphData);
                updateDetailedStats(stats);
                
                // Step 4: Switch to analysis tab
                switchTab('analysis');
                
            } catch (error) {
                console.error('Analysis workflow failed:', error);
            } finally {
                analyzeBtn.disabled = false;
                analyzeBtn.innerHTML = '<i data-lucide="search"></i> ë¶„ì„ ì‹œì‘';
                lucide.createIcons();
            }
        }

        async function refreshGraph() {
            refreshBtn.disabled = true;
            document.getElementById('refresh-btn-text').textContent = 'ìƒˆë¡œê³ ì¹¨ ì¤‘...';
            
            try {
                const graphData = await getGraphData();
                createGraph3D(graphData);
                showToast('check-circle-2', 'ê·¸ë˜í”„ê°€ ìƒˆë¡œê³ ì¹¨ë˜ì—ˆìŠµë‹ˆë‹¤.');
            } catch (error) {
                console.error('Refresh failed:', error);
            } finally {
                refreshBtn.disabled = false;
                document.getElementById('refresh-btn-text').textContent = '3D ê·¸ë˜í”„ ìƒˆë¡œê³ ì¹¨';
            }
        }

        function initialize() {
            lucide.createIcons();
            init3D();
            
            // Event listeners
            analyzeBtn.addEventListener('click', runAnalysisWorkflow);
            refreshBtn.addEventListener('click', refreshGraph);
            
            sidebarToggle.addEventListener('click', () => {
                sidebar.classList.toggle('open');
                const newIconName = sidebar.classList.contains('open') ? 'panel-right-close' : 'panel-left-close';
                sidebarToggle.innerHTML = `<i data-lucide="${newIconName}"></i>`;
                lucide.createIcons();
            });
            
            // Tab switching
            tabAnalysis.addEventListener('click', () => switchTab('analysis'));
            tabCode.addEventListener('click', () => switchTab('code'));
            tabStats.addEventListener('click', () => switchTab('stats'));
            
            // Check if API is available
            fetch(`${API_BASE_URL}/health`)
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'healthy') {
                        showToast('check-circle-2', 'Cody API ì—°ê²°ë¨ âœ¨');
                    } else {
                        showToast('alert-triangle', 'API ì—°ê²° ë¶ˆì•ˆì •');
                    }
                })
                .catch(() => {
                    showToast('alert-triangle', 'API ì„œë²„ì— ì—°ê²°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì„œë²„ê°€ ì‹¤í–‰ ì¤‘ì¸ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.');
                });
        }

        initialize();
    </script>
</body>
</html>
