<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cody: 3D 인터랙티브 코드 분석 (우주 테마)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect"             const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.3; // 임계값을 낮춰서 더 많은 노드가 빛나도록
            bloomPass.strength = 4.0;  // 블룸 강도 최대로
            bloomPass.radius = 1.5;    // 블룸 반지름 최대로"https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/"
        }
    }
    </script>
    <style>
        body {
            font-family: 'Inter', 'Noto Sans KR', sans-serif;
            background-color: #000005;
            color: #f0f0f0;
            overflow: hidden;
        }
        #main-canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        .sidebar {
            position: fixed;
            top: 0;
            left: 0;
            height: 100%;
            width: 450px;
            transform: translateX(-100%);
            transition: transform 0.4s ease-in-out;
            z-index: 10;
            display: flex;
            flex-direction: column;
        }
        .sidebar.open {
            transform: translateX(0);
        }
        .sidebar-toggle {
            position: fixed;
            top: 50%;
            left: 1rem;
            transform: translateY(-50%);
            z-index: 11;
            transition: left 0.4s ease-in-out;
        }
        .sidebar.open + .sidebar-toggle {
            left: 460px;
        }
        .glassmorphism {
            background: rgba(10, 10, 15, 0.7);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .code-editor {
            font-family: 'D2Coding', 'SF Mono', 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.6;
            background-color: rgba(0, 0, 5, 0.8);
            color: #a9b1d6;
            border-radius: 0.5rem;
            padding: 1rem;
            height: calc(100vh - 350px);
            overflow: auto;
            white-space: pre-wrap;
            border: 1px solid rgba(255, 255, 255, 0.15);
        }
        .tab-button.active { color: #818cf8; border-bottom-color: #818cf8; }
        .node-label {
            color: #ffffff;
            background: rgba(0, 0, 0, 0.8);
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: bold;
            pointer-events: none;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.3);
            white-space: nowrap;
            min-width: 60px;
            text-align: center;
        }
        .bottom-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            z-index: 5;
        }
        #toast-container {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 20;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        .toast {
            transition: all 0.5s ease-in-out;
            opacity: 0;
            transform: translateX(100%);
        }
        .toast.show {
            opacity: 1;
            transform: translateX(0);
        }
        .file-input {
            background: rgba(30, 30, 40, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 0.5rem;
            padding: 0.5rem;
            color: #e0e0e0;
            width: 100%;
            margin-bottom: 1rem;
        }
        .dead-code {
            color: #ff6b6b !important;
        }
        .high-call-count {
            color: #ffd93d !important;
        }
    </style>
</head>
<body>
    <div id="main-canvas-container"></div>
    <div id="toast-container"></div>

    <aside id="sidebar" class="sidebar glassmorphism p-4">
        <div class="flex-grow flex flex-col">
            <h2 class="text-2xl font-bold text-white mb-4">🤖 Cody</h2>
            
            <!-- Project Path Input -->
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-300 mb-2">분석할 프로젝트 경로</label>
                <input type="text" id="project-path" class="file-input" 
                       placeholder="예: C:\path\to\your\project" 
                       value="sample_project">
                <button id="analyze-btn" class="w-full bg-blue-600 text-white py-2 px-4 rounded hover:bg-blue-700 transition">
                    <i data-lucide="search"></i> 분석 시작
                </button>
            </div>

            <div class="border-b border-gray-700 mb-4">
                <nav class="-mb-px flex space-x-6" aria-label="Tabs">
                    <button id="tab-analysis" class="tab-button active py-3 px-1 text-base font-medium border-b-2 border-transparent transition">분석 결과</button>
                    <button id="tab-code" class="tab-button py-3 px-1 text-base font-medium text-gray-400 border-b-2 border-transparent transition">코드 뷰</button>
                    <button id="tab-stats" class="tab-button py-3 px-1 text-base font-medium text-gray-400 border-b-2 border-transparent transition">통계</button>
                </nav>
            </div>
            
            <div id="content-analysis" class="flex-grow">
                <h3 class="font-semibold mb-2 text-gray-200">🌌 코드 우주 분석</h3>
                <div id="analysis-info" class="bg-gray-800/50 p-3 rounded-lg text-sm space-y-2 mb-4">
                    <p>프로젝트를 분석하면 3D 우주가 생성됩니다.</p>
                    <ul class="text-xs space-y-1 text-gray-400">
                        <li>🌟 <strong>밝은 노드</strong>: 많이 호출되는 함수</li>
                        <li>💀 <strong>빨간 노드</strong>: Dead Code (미사용 코드)</li>
                        <li>🔗 <strong>연결선</strong>: 함수 호출 관계</li>
                        <li>🎯 <strong>클릭</strong>: 노드 정보 확인</li>
                    </ul>
                </div>
                <div id="node-details" class="bg-gray-800/50 p-3 rounded-lg text-sm hidden">
                    <h4 class="font-semibold text-white mb-2">선택된 노드</h4>
                    <div id="node-info"></div>
                </div>
            </div>
            
            <div id="content-code" class="hidden flex-grow">
                <h3 class="font-semibold mb-2 text-gray-200">📄 코드 미리보기</h3>
                <div id="code-viewer" class="code-editor">
                    분석 후 코드가 여기에 표시됩니다.
                </div>
            </div>
            
            <div id="content-stats" class="hidden flex-grow">
                <h3 class="font-semibold mb-2 text-gray-200">📊 상세 통계</h3>
                <div id="detailed-stats" class="bg-gray-800/50 p-3 rounded-lg text-sm space-y-2">
                    분석 후 상세 통계가 여기에 표시됩니다.
                </div>
            </div>
        </div>
    </aside>
    
    <button id="sidebar-toggle" class="sidebar-toggle glassmorphism p-2 rounded-full text-white transition-all duration-400">
        <i data-lucide="panel-left-close"></i>
    </button>

    <div class="bottom-bar p-4 flex justify-center">
        <div class="w-full max-w-2xl">
            <div class="glassmorphism p-4 rounded-xl shadow-2xl">
                <button id="refresh-btn" class="w-full bg-indigo-600 text-white font-bold py-3 px-6 rounded-lg hover:bg-indigo-700 focus:outline-none focus:ring-4 focus:ring-indigo-500/50 transition-all duration-300 flex items-center justify-center text-lg shadow-lg">
                    <i data-lucide="refresh-cw" class="mr-2"></i>
                    <span id="refresh-btn-text">3D 그래프 새로고침</span>
                </button>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- Configuration ---
        const API_BASE_URL = 'http://127.0.0.1:8000';

        // --- UI Elements ---
        const analyzeBtn = document.getElementById('analyze-btn');
        const refreshBtn = document.getElementById('refresh-btn');
        const projectPathInput = document.getElementById('project-path');
        const sidebar = document.getElementById('sidebar');
        const sidebarToggle = document.getElementById('sidebar-toggle');
        
        // Tab elements
        const tabAnalysis = document.getElementById('tab-analysis');
        const tabCode = document.getElementById('tab-code');
        const tabStats = document.getElementById('tab-stats');
        const contentAnalysis = document.getElementById('content-analysis');
        const contentCode = document.getElementById('content-code');
        const contentStats = document.getElementById('content-stats');
        
        // Content elements
        const analysisInfo = document.getElementById('analysis-info');
        const nodeDetails = document.getElementById('node-details');
        const nodeInfo = document.getElementById('node-info');
        const codeViewer = document.getElementById('code-viewer');
        const detailedStats = document.getElementById('detailed-stats');

        // --- API Functions ---
        async function analyzeProject(projectPath) {
            try {
                showToast('search', '프로젝트 분석 시작...');
                
                const response = await fetch(`${API_BASE_URL}/analyze`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ path: projectPath })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const result = await response.json();
                showToast('check-circle-2', `분석 완료! ${result.nodes_count}개 노드, ${result.edges_count}개 연결`);
                return result;
            } catch (error) {
                console.error('Analysis error:', error);
                showToast('alert-triangle', `분석 실패: ${error.message}`);
                throw error;
            }
        }

        async function getGraphData() {
            try {
                const response = await fetch(`${API_BASE_URL}/graph-data`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                return await response.json();
            } catch (error) {
                console.error('Graph data error:', error);
                showToast('alert-triangle', `그래프 데이터 로드 실패: ${error.message}`);
                throw error;
            }
        }

        async function getStatistics() {
            try {
                const response = await fetch(`${API_BASE_URL}/statistics`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                return await response.json();
            } catch (error) {
                console.error('Statistics error:', error);
                return {};
            }
        }

        // --- 3D Scene Setup ---
        let scene, camera, renderer, labelRenderer, controls, composer;
        let nodeObjects = new Map();
        let edgeObjects = [];
        let raycaster, mouse;
        let currentGraphData = null;
        
        const canvasContainer = document.getElementById('main-canvas-container');

        function onWindowResize() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
            labelRenderer.setSize(width, height);
            composer.setSize(width, height);
        }

        function init3D() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 0, 120); // 카메라를 더 뒤로

            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            canvasContainer.appendChild(renderer.domElement);

            labelRenderer = new CSS2DRenderer();
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0px';
            labelRenderer.domElement.style.pointerEvents = 'none';
            canvasContainer.appendChild(labelRenderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 20;
            controls.maxDistance = 300;
            controls.autoRotate = false; // 자동 회전 비활성화
            controls.enablePan = true;

            // Mouse interaction setup
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            renderer.domElement.addEventListener('click', onMouseClick);

            scene.add(new THREE.AmbientLight(0xffffff, 0.2));
            const pointLight = new THREE.PointLight(0xffffff, 0.8);
            scene.add(pointLight);

            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.5; // 높은 임계값으로 자주 사용되는 것만 블룸
            bloomPass.strength = 2.0;  // 블룸 강도 증가
            bloomPass.radius = 1.0;    // 블룸 반경 증가

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            createStarfield();
            window.addEventListener('resize', onWindowResize);
            animate();
        }

        function onMouseClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const sprites = Array.from(nodeObjects.values()).map(n => n.sprite);
            const intersects = raycaster.intersectObjects(sprites);

            if (intersects.length > 0) {
                const clickedSprite = intersects[0].object;
                const nodeData = Array.from(nodeObjects.values()).find(n => n.sprite === clickedSprite)?.data;
                
                if (nodeData) {
                    displayNodeDetails(nodeData);
                    switchTab('analysis');
                }
            }
        }

        function displayNodeDetails(nodeData) {
            nodeDetails.classList.remove('hidden');
            const callCount = nodeData.callCount || 0;
            const isDead = nodeData.dead || false;
            const isUnused = callCount === 0 && !isDead;
            
            let statusText = '';
            let statusClass = '';
            
            if (isDead) {
                statusText = '⚠️ 데드 코드 (vulture 분석)';
                statusClass = 'text-red-400';
            } else if (callCount > 5) {
                statusText = '🔥 자주 사용되는 핵심 함수';
                statusClass = 'text-yellow-400';
            } else if (isUnused) {
                statusText = '💤 호출 안됨 (하지만 필요한 코드)';
                statusClass = 'text-gray-400';
            } else if (nodeData.type === 'class') {
                statusText = '🏗️ 클래스 정의';
                statusClass = 'text-purple-400';
            } else {
                statusText = '✅ 일반 함수';
                statusClass = 'text-blue-400';
            }
            
            nodeInfo.innerHTML = `
                <p><strong>이름:</strong> ${nodeData.name}</p>
                <p><strong>타입:</strong> ${nodeData.type}</p>
                <p><strong>파일:</strong> ${nodeData.file}</p>
                <p><strong>호출 횟수:</strong> ${callCount}회</p>
                <p><strong>상태:</strong> <span class="${statusClass}">${statusText}</span></p>
                ${isDead ? '<p class="text-red-400 text-xs mt-1">⚠️ 이 코드는 실제로 사용되지 않습니다. 제거를 고려해보세요.</p>' : ''}
                ${isUnused ? '<p class="text-gray-400 text-xs mt-1">💡 AST에서 호출이 감지되지 않았지만, vulture는 필요한 코드라고 판단했습니다.</p>' : ''}
                ${callCount > 5 ? '<p class="text-yellow-400 text-xs mt-1">🚀 이 함수는 프로젝트의 핵심 로직입니다.</p>' : ''}
            `;
        }

        function createStarfield() {
            const starGeometry = new THREE.BufferGeometry();
            const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.1, transparent: true, opacity: 0.5 });
            const starVertices = [];
            for (let i = 0; i < 10000; i++) {
                const x = (Math.random() - 0.5) * 3000;
                const y = (Math.random() - 0.5) * 3000;
                const z = (Math.random() - 0.5) * 3000;
                starVertices.push(x, y, z);
            }
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        }

        function createStarTexture(color, isDead = false, isHighUsage = false) {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const context = canvas.getContext('2d');
            
            if (isDead) {
                // Dead code - 거의 보이지 않을 정도로 어둡게
                const gradient = context.createRadialGradient(64, 64, 0, 64, 64, 64);
                gradient.addColorStop(0, 'rgba(30, 8, 8, 0.6)');
                gradient.addColorStop(0.5, 'rgba(20, 5, 5, 0.3)');
                gradient.addColorStop(1, 'rgba(10, 2, 2, 0)');
                context.fillStyle = gradient;
                context.fillRect(0, 0, 128, 128);
            } else if (isHighUsage) {
                // 자주 사용 - 태양처럼 극도로 밝게
                const gradient = context.createRadialGradient(64, 64, 0, 64, 64, 64);
                gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                gradient.addColorStop(0.05, 'rgba(255, 255, 255, 1)');
                gradient.addColorStop(0.15, 'rgba(255, 255, 200, 1)');
                gradient.addColorStop(0.4, 'rgba(255, 220, 100, 1)');
                gradient.addColorStop(0.7, 'rgba(255, 180, 50, 0.9)');
                gradient.addColorStop(1, 'rgba(255, 140, 0, 0)');
                context.fillStyle = gradient;
                context.fillRect(0, 0, 128, 128);
                
                // 극도로 강한 글로우 효과
                context.globalCompositeOperation = 'lighter';
                const glowGradient = context.createRadialGradient(64, 64, 0, 64, 64, 110);
                glowGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                glowGradient.addColorStop(0.1, 'rgba(255, 255, 220, 0.9)');
                glowGradient.addColorStop(0.3, 'rgba(255, 240, 150, 0.7)');
                glowGradient.addColorStop(0.6, 'rgba(255, 220, 100, 0.4)');
                glowGradient.addColorStop(1, 'rgba(255, 200, 50, 0)');
                context.fillStyle = glowGradient;
                context.fillRect(0, 0, 128, 128);
            } else {
                // 일반 함수/클래스 - 차분하고 어둡게, 블룸 없음
                const gradient = context.createRadialGradient(64, 64, 0, 64, 64, 64);
                gradient.addColorStop(0, color.replace('1)', '0.7)'));
                gradient.addColorStop(0.4, color.replace('1)', '0.4)'));
                gradient.addColorStop(0.8, color.replace('1)', '0.2)'));
                gradient.addColorStop(1, color.replace('1)', '0)'));
                context.fillStyle = gradient;
                context.fillRect(0, 0, 128, 128);
            }
            
            return new THREE.CanvasTexture(canvas);
        }
        
        function createGraph3D(graphData) {
            // Clear existing objects
            nodeObjects.forEach(obj => {
                scene.remove(obj.sprite);
            });
            edgeObjects.forEach(obj => {
                scene.remove(obj);
            });
            nodeObjects.clear();
            edgeObjects = [];
            
            currentGraphData = graphData;
            
            if (!graphData.nodes || graphData.nodes.length === 0) {
                showToast('alert-triangle', '표시할 노드가 없습니다.');
                return;
            }

            const nodeCount = graphData.nodes.length;
            const radius = Math.max(30, 15 + nodeCount * 0.8); // 반지름 크게 증가

            graphData.nodes.forEach((nodeData, i) => {
                // 더 넓게 분산된 구형 배치
                const phi = Math.acos(-1 + (2 * i) / nodeCount);
                const theta = Math.sqrt(nodeCount * Math.PI) * phi * 1.5; // 더 넓게 분산

                // Determine color and size based on node properties
                const isDead = nodeData.dead || false;
                const callCount = nodeData.callCount || 0;
                const isHighUsage = callCount > 3;
                const isUnused = callCount === 0 && !isDead; // 호출횟수 0이지만 데드코드 아님
                
                let color, size, blending, opacity;
                if (isDead) {
                    // 진짜 데드코드: 극도로 어둡고 작게, 빨간색
                    color = 'rgba(40, 10, 10, 1)';
                    size = 0.5;
                    blending = THREE.NormalBlending;
                    opacity = 0.4;
                } else if (isHighUsage) {
                    // 자주 사용: 극도로 크고 밝게, 황금색
                    color = 'rgba(255, 255, 255, 1)';
                    size = 6.0 + (callCount * 0.5);
                    blending = THREE.AdditiveBlending;
                    opacity = 1.0;
                } else if (nodeData.type === 'class') {
                    // 클래스: 보라색, 중간 크기
                    color = 'rgba(150, 120, 200, 1)';
                    size = 2.5;
                    blending = THREE.NormalBlending;
                    opacity = 0.8;
                } else if (isUnused) {
                    // 호출횟수 0이지만 사용되는 함수: 회색, 작은 크기
                    color = 'rgba(120, 120, 120, 1)';
                    size = 1.2;
                    blending = THREE.NormalBlending;
                    opacity = 0.6;
                } else {
                    // 일반 함수: 파란색, 보통 크기
                    color = 'rgba(100, 150, 220, 1)';
                    size = 2.0;
                    blending = THREE.NormalBlending;
                    opacity = 0.7;
                }

                const starMaterial = new THREE.SpriteMaterial({
                    map: createStarTexture(color, isDead, isHighUsage),
                    blending: blending,
                    depthWrite: false,
                    transparent: true,
                    opacity: opacity
                });

                const sprite = new THREE.Sprite(starMaterial);
                sprite.scale.set(size * 2.0, size * 2.0, 1); // 전체적으로 더 크게
                
                const position = new THREE.Vector3();
                position.setFromSphericalCoords(radius, phi, theta);
                sprite.position.copy(position);
                
                // Create label with color coding
                const labelElement = document.createElement('div');
                labelElement.className = 'node-label';
                labelElement.style.fontSize = '14px';
                labelElement.style.fontWeight = 'bold';
                labelElement.style.padding = '4px 8px';
                labelElement.style.borderRadius = '6px';
                labelElement.style.border = '1px solid rgba(255, 255, 255, 0.3)';
                labelElement.style.textShadow = '1px 1px 2px rgba(0, 0, 0, 0.8)';
                labelElement.style.whiteSpace = 'nowrap';
                labelElement.style.pointerEvents = 'none';
                
                if (isDead) {
                    labelElement.classList.add('dead-code');
                    labelElement.style.backgroundColor = 'rgba(220, 40, 40, 1)';
                    labelElement.style.color = '#ffffff';
                    labelElement.style.border = '2px solid rgba(255, 80, 80, 0.8)';
                    labelElement.style.fontWeight = 'bold';
                    labelElement.style.textShadow = '2px 2px 4px rgba(0, 0, 0, 1)';
                } else if (isHighUsage) {
                    labelElement.classList.add('high-call-count');
                    labelElement.style.backgroundColor = 'rgba(255, 220, 60, 1)';
                    labelElement.style.color = '#000000';
                    labelElement.style.border = '2px solid rgba(255, 240, 120, 1)';
                    labelElement.style.fontWeight = 'bold';
                    labelElement.style.textShadow = '1px 1px 3px rgba(0, 0, 0, 0.8)';
                } else if (nodeData.type === 'class') {
                    labelElement.style.backgroundColor = 'rgba(150, 120, 200, 0.9)';
                    labelElement.style.color = '#ffffff';
                    labelElement.style.border = '1px solid rgba(180, 150, 220, 0.8)';
                } else if (isUnused) {
                    labelElement.style.backgroundColor = 'rgba(120, 120, 120, 0.8)';
                    labelElement.style.color = '#ffffff';
                    labelElement.style.border = '1px solid rgba(160, 160, 160, 0.6)';
                } else {
                    labelElement.style.backgroundColor = 'rgba(100, 150, 220, 0.8)';
                    labelElement.style.color = '#ffffff';
                    labelElement.style.border = '1px solid rgba(130, 170, 240, 0.6)';
                }
                
                labelElement.textContent = nodeData.name || nodeData.label;
                
                const label = new CSS2DObject(labelElement);
                label.position.set(0, size * 1.2, 0); // 라벨을 더 위로
                sprite.add(label);

                scene.add(sprite);
                nodeObjects.set(nodeData.id, { sprite, data: nodeData });
            });

            // Create edges/connections
            if (graphData.links) {
                graphData.links.forEach(linkData => {
                    const fromNode = nodeObjects.get(linkData.source);
                    const toNode = nodeObjects.get(linkData.target);
                    if (fromNode && toNode) {
                        const material = new THREE.MeshBasicMaterial({ 
                            color: 0x00ffff, 
                            transparent: true, 
                            opacity: 0.4 
                        });
                        const path = new THREE.LineCurve3(fromNode.sprite.position, toNode.sprite.position);
                        const geometry = new THREE.TubeGeometry(path, 2, 0.02, 8, false);
                        const tube = new THREE.Mesh(geometry, material);
                        scene.add(tube);
                        edgeObjects.push(tube);
                    }
                });
            }

            showToast('sparkles', `3D 우주 생성 완료! ${nodeCount}개 노드, ${edgeObjects.length}개 연결`);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            composer.render();
            labelRenderer.render(scene, camera);
        }

        function showToast(icon, text) {
            const toastContainer = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = 'toast glassmorphism p-3 rounded-lg flex items-center shadow-lg';
            toast.innerHTML = `<i data-lucide="${icon}" class="w-5 h-5 mr-3 text-indigo-400"></i><span>${text}</span>`;
            
            toastContainer.appendChild(toast);
            lucide.createIcons();

            setTimeout(() => toast.classList.add('show'), 10);
            setTimeout(() => {
                toast.classList.remove('show');
                toast.addEventListener('transitionend', () => toast.remove());
            }, 4000);
        }

        function switchTab(tabName) {
            // Reset all tabs
            [tabAnalysis, tabCode, tabStats].forEach(tab => tab.classList.remove('active'));
            [contentAnalysis, contentCode, contentStats].forEach(content => content.classList.add('hidden'));
            
            // Activate selected tab
            if (tabName === 'analysis') {
                tabAnalysis.classList.add('active');
                contentAnalysis.classList.remove('hidden');
            } else if (tabName === 'code') {
                tabCode.classList.add('active');
                contentCode.classList.remove('hidden');
            } else if (tabName === 'stats') {
                tabStats.classList.add('active');
                contentStats.classList.remove('hidden');
            }
        }
        
        function updateAnalysisInfo(analysisResult) {
            analysisInfo.innerHTML = `
                <div class="space-y-2">
                    <p><strong>✨ 분석 완료!</strong></p>
                    <p>🌟 <strong>노드:</strong> ${analysisResult.nodes_count}개</p>
                    <p>🔗 <strong>연결:</strong> ${analysisResult.edges_count}개</p>
                    <p class="text-xs text-gray-400 mt-2">3D 우주에서 노드를 클릭하여 자세한 정보를 확인하세요.</p>
                </div>
            `;
        }
        
        function updateDetailedStats(stats) {
            if (!stats || Object.keys(stats).length === 0) {
                detailedStats.innerHTML = '<p class="text-gray-400">통계 데이터가 없습니다.</p>';
                return;
            }
            
            let html = `
                <div class="space-y-3">
                    <div>
                        <h4 class="font-semibold text-white mb-1">📊 전체 현황</h4>
                        <p>전체 노드: ${stats.total_nodes || 0}개</p>
                        <p>전체 관계: ${stats.total_relationships || 0}개</p>
                        <p>💀 Dead Code: ${stats.dead_code_count || 0}개</p>
                    </div>
            `;
            
            if (stats.by_type) {
                html += `
                    <div>
                        <h4 class="font-semibold text-white mb-1">📋 타입별 분포</h4>
                `;
                for (const [type, count] of Object.entries(stats.by_type)) {
                    html += `<p>${type}: ${count}개</p>`;
                }
                html += `</div>`;
            }
            
            if (stats.most_called && stats.most_called.length > 0) {
                html += `
                    <div>
                        <h4 class="font-semibold text-white mb-1">🔥 최다 호출 함수</h4>
                `;
                stats.most_called.slice(0, 5).forEach((item, i) => {
                    html += `<p class="text-sm">${i+1}. ${item.name} (${item.callCount}회)</p>`;
                });
                html += `</div>`;
            }
            
            html += '</div>';
            detailedStats.innerHTML = html;
        }

        async function runAnalysisWorkflow() {
            const projectPath = projectPathInput.value.trim();
            if (!projectPath) {
                showToast('alert-triangle', '프로젝트 경로를 입력해주세요.');
                return;
            }

            analyzeBtn.disabled = true;
            analyzeBtn.innerHTML = '<i data-lucide="loader-2" class="animate-spin"></i> 분석 중...';
            
            try {
                // Step 1: Analyze project
                const analysisResult = await analyzeProject(projectPath);
                updateAnalysisInfo(analysisResult);
                
                // Step 2: Get graph data and statistics
                const [graphData, stats] = await Promise.all([
                    getGraphData(),
                    getStatistics()
                ]);
                
                // Step 3: Create 3D visualization
                createGraph3D(graphData);
                updateDetailedStats(stats);
                
                // Step 4: Switch to analysis tab
                switchTab('analysis');
                
            } catch (error) {
                console.error('Analysis workflow failed:', error);
            } finally {
                analyzeBtn.disabled = false;
                analyzeBtn.innerHTML = '<i data-lucide="search"></i> 분석 시작';
                lucide.createIcons();
            }
        }

        async function refreshGraph() {
            refreshBtn.disabled = true;
            document.getElementById('refresh-btn-text').textContent = '새로고침 중...';
            
            try {
                const graphData = await getGraphData();
                createGraph3D(graphData);
                showToast('check-circle-2', '그래프가 새로고침되었습니다.');
            } catch (error) {
                console.error('Refresh failed:', error);
            } finally {
                refreshBtn.disabled = false;
                document.getElementById('refresh-btn-text').textContent = '3D 그래프 새로고침';
            }
        }

        function initialize() {
            lucide.createIcons();
            init3D();
            
            // Event listeners
            analyzeBtn.addEventListener('click', runAnalysisWorkflow);
            refreshBtn.addEventListener('click', refreshGraph);
            
            sidebarToggle.addEventListener('click', () => {
                sidebar.classList.toggle('open');
                const newIconName = sidebar.classList.contains('open') ? 'panel-right-close' : 'panel-left-close';
                sidebarToggle.innerHTML = `<i data-lucide="${newIconName}"></i>`;
                lucide.createIcons();
            });
            
            // Tab switching
            tabAnalysis.addEventListener('click', () => switchTab('analysis'));
            tabCode.addEventListener('click', () => switchTab('code'));
            tabStats.addEventListener('click', () => switchTab('stats'));
            
            // Check if API is available
            fetch(`${API_BASE_URL}/health`)
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'healthy') {
                        showToast('check-circle-2', 'Cody API 연결됨 ✨');
                    } else {
                        showToast('alert-triangle', 'API 연결 불안정');
                    }
                })
                .catch(() => {
                    showToast('alert-triangle', 'API 서버에 연결할 수 없습니다. 서버가 실행 중인지 확인해주세요.');
                });
        }

        initialize();
    </script>
</body>
</html>
